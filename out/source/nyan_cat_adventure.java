/* autogenerated by Processing revision 1282 on 2022-06-05 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import ddf.minim.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class nyan_cat_adventure extends PApplet {

//music part

Minim minim;
AudioSample bomb;
AudioSample carAccident;
AudioPlayer carSound;//ok
AudioSample gameover;
AudioSample click;//ok
AudioSample drop;
AudioSample eatMoney;
AudioSample jump;//ok
AudioSample magnet;
AudioSample nyna;
AudioSample river;
//AudioSample win;
//AudioSample wood;
boolean isPlaying = true;

//FONT
PFont bit;

PImage playerImg, nyan0, coinImg, nyandead, gameOver, gameStart, bombImg,rainbow;
PImage[] tree=new PImage[4];
PImage[] car=new PImage[4];
PImage[] carR=new PImage[4];
PImage[] truck=new PImage[2];
PImage[] nyanUP= new PImage[3];
PImage[] nyanR= new PImage[3];
PImage[] nyanL= new PImage[3];
PImage[] nyanD= new PImage[3];
PImage[] nyanDead= new PImage[3];
PImage[] nyanRun=new PImage[5];
PImage cookieImg,flatCoinImg; //replace this with coin image
int landX, landY;
float speedRate;
float tranX=0, tranY=0;
Player player;
int playerState;
final int PLAYER_IDLE=0, PLAYER_UP=1, PLAYER_DOWN=2, PLAYER_RIGHT=3, PLAYER_LEFT=4;
final int CAT_PADX=30;
final int GAME_START = 0, GAME_RUN = 1, GAME_OVER = 2, NYAN_MODE=3;
int gameState = 0;
int coinCount=0;
int hiScore=0;
int hintTimer, skin;
float hintX, hintY;
boolean bombMode=false;
int bombTimer;
boolean[] skinStatus=new boolean[3];
NyanCatRun nyan;


//final Variables for item rate
final int BOMB_RATE=36;
final int COIN_RATE=5;
final int COOKIE_RATE=70;

boolean debugMode=false;
Map[] maps=new Map[40];
final int ROAD=1, GRASS=0;
final int TREE=1;
final int CAR=1;


 public void initGame() {
  speedRate=1;
  for (int i=0; i<maps.length; i++) {
    if (i<16) {
      maps[i]=new Grass(20-i);
    } else {
      switch(floor(random(2))) {
      case 0:
        maps[i]=new Grass(20-i);
        break;
      case 1:
        maps[i]=new Road(20-i);
        break;
      }
    }
  }
  skin=0;
  playerImg=nyanUP[skin];
  speedRate=1;
}


 public void setup() {
  /* size commented out by preprocessor */;
  noStroke();
  bit = createFont("8-BIT WONDER.TTF", 100);
  background(0);
  textFont(bit);
  text("Loading", width/2-300, height/2);
  cookieImg=loadImage("img/cookie.png");
  coinImg=loadImage("img/coin.png");
  bombImg=loadImage("img/bomb.png");
  gameOver=loadImage("img/gameOver.png");
  gameStart=loadImage("img/start.png");
  flatCoinImg=loadImage("img/flatCoin.png");
  rainbow=loadImage("img/Rainbow.png");

  //music files loading
  minim = new Minim(this);
  bomb = minim.loadSample("music/bomb.mp3");
  carAccident = minim.loadSample("music/car accident.mp3");
  carSound = minim.loadFile("music/car.mp3");
  gameover = minim.loadSample("music/gameover.mp3");
  click = minim.loadSample("music/click.mp3");
  drop = minim.loadSample("music/drop.mp3");
  eatMoney = minim.loadSample("music/eat money.mp3");
  jump = minim.loadSample("music/jump.mp3");
  magnet = minim.loadSample("music/magnet.mp3");
  nyna = minim.loadSample("music/nyna.mp3");
  river = minim.loadSample("music/river.mp3");
  //  win = minim.loadSample("music/win.mp3");
  //  wood = minim.loadSample("music/wood.mp3");
  carSound.loop();




  //loading nyan Image
  for (int i=0; i<3; i++) {
    nyanUP[i]=loadImage("img/nyan" + i + ".png") ;
    nyanR[i]=loadImage("img/nyan" + i + "R.png") ;
    nyanL[i]=loadImage("img/nyan" + i + "L.png") ;
    nyanD[i]=loadImage("img/nyan" + i + "D.png") ;
    nyanDead[i]=loadImage("img/deadNyan" + i + ".png") ;
    skinStatus[i]=false;
  }
  skinStatus[0]=true;

  //loading Tree & Car Image
  for (int i=0; i<4; i++) {
    tree[i] = loadImage("img/tree" + i + ".png") ;
    car[i] = loadImage("img/car" + i + ".png") ;
    carR[i] = loadImage("img/car" + i + "_R.png");
  }
  
  for (int i=0; i<5; i++) {
    nyanRun[i]=loadImage("img/nyanRun" + i + ".png") ;
  }

  for (int i=0; i<2; i++) {
    truck[i] = loadImage("img/truck" + i + ".png") ;
  }



  initGame();

  player = new Player();
}


 public void draw() {
  
  //update carspeed
  speedRate=1+floor(score()/50)*0.25f;
  
  pushMatrix();
  //Adjust Rolling Speed
  switch (gameState) {

  case GAME_START:
    if (tranX<-400) {
      tranX=-400;
      tranY=800;
    }
    if (tranX<0) {
      for (int i=-400; i<=0; i=i+20) {
        if (tranX<=i) {
          tranX+=1;
          tranY-=2;
        }
      }
    }
    break;
  case GAME_RUN:
    for (int i=550; i>=0; i=i-25) {
      if (tranY+player.y<=i) {
        tranX-=0.125f;
        tranY+=0.25f;
      }
    }
    tranX-=0.125f;
    tranY+=0.25f;
    break;
  case GAME_OVER:

    playerImg = nyanDead[skin];
    break;
  }

  //bombTimer
  if (bombMode) {
    bombTimer-=1;
    if (bombTimer<0) {
      bombMode=false;
    }
  }


  //Rolling the screen
  translate(tranX, tranY);


  //draw map

  for (int j=39; j>=0; j--) {
    maps[j].display();
  }
  for (int j=39; j>0; j--) {
    roadMarkingLine(j);
  }

  //draw objects
  for (int j=39; j>=13; j--) {
    maps[j].displayObjects();
  }

  //drawPlayer
  player.update();

  //draw objects
  for (int j=12; j>=0; j--) {
    maps[j].displayObjects();
  }

  popMatrix();

  switch (gameState) {
  case GAME_START:
    drawSkinBar();
    image(gameStart, 400, 200);
    break;

  case GAME_OVER:
    if (hintTimer>0) {
      hintTimer--;
      //hintX+=4;
      //hintY+=1;
      for (int i=0; i<hintTimer; i++) {
        hintX+=(0.4f*hintTimer/32);
        hintY+=(0.1f*hintTimer/32);
      }
    }
    drawImage(gameOver, hintX-80, hintY);
    break;

  case NYAN_MODE:
    nyan.display();
    break;
  }

  //draw score


  drawScore();

  //detect if cat is out of the screen

  if (tranY+ player.y-720-60>0 && gameState==GAME_RUN) {
    gameState=GAME_OVER;
    hintTimer=60;
    hintX=-400;
    hintY=150;
  }
}

 public void keyPressed() {
  // Add your moving input code here
  if (key ==CODED) {
    switch(keyCode) {
    case UP:
      if (gameState==GAME_START && tranX>=0) {
        gameState=GAME_RUN;
      }
      if (gameState==GAME_RUN && playerState==PLAYER_IDLE && maps[13].checkObjects(player.offsetX)!=TREE) {
        playerState=PLAYER_UP;
        jump.trigger();
        player.movingTimer=0;
        player.offsetY--;
        //offset map forward and create new map
        for (int i=0; i<39; i++) {
          maps[i]=maps[i+1];
        }
        switch(floor(random(3))) {
        case 0:
          maps[39]=new Grass(player.offsetY-27);
          break;
        case 1:
          maps[39]=new Road(player.offsetY-27);
          break;
        case 2:
          maps[39]=new Road(player.offsetY-27);
          break;
        }
      }


      break;
    case RIGHT:
      if (gameState==GAME_RUN && playerState==PLAYER_IDLE && player.offsetX<8 && maps[12].checkObjects(player.offsetX+1)!=TREE) {
        playerState=PLAYER_RIGHT;
        jump.trigger();
        player.movingTimer=0;
        player.offsetX++;
      }
      break;
    case LEFT:
      if (gameState==GAME_RUN && playerState==PLAYER_IDLE && player.offsetX>0 && maps[12].checkObjects(player.offsetX-1)!=TREE) {
        playerState=PLAYER_LEFT;
        jump.trigger();
        player.movingTimer=0;
        player.offsetX--;
      }
      break;
    case DOWN:
      if (gameState==GAME_RUN && playerState==PLAYER_IDLE && maps[11].checkObjects(player.offsetX)!=TREE) {
        playerState=PLAYER_DOWN;
        jump.trigger();
        player.movingTimer=0;
        player.offsetY++;

        //offset map backward and create new map
        for (int i=39; i>0; i--) {
          maps[i]=maps[i-1];
        }
      }
      break;
    }
  } else {
    if (key=='b') {
      // Press B to toggle demo mode
      debugMode = !debugMode;
    }
    if (key==ENTER) {
      if (gameState==GAME_OVER) {
        gameState=GAME_START;
        player.x=560;
        player.y=680;
        player.offsetX=4;
        player.offsetY=8;
        player.movingTimer=0;
        playerImg = nyanUP[skin];
        click.trigger();
        initGame();
      }
    }
    if (key=='1') {
      if (gameState==GAME_START && skinStatus[0]) {
        skin=0;
        playerImg=nyanUP[skin];
      } else if (gameState==GAME_START && !skinStatus[0] &&coinCount>=100) {
        coinCount-=100;
        skin=0;
        playerImg=nyanUP[skin];
        skinStatus[0]=!skinStatus[0];
      }
    }
    if (key=='2') {
      if (gameState==GAME_START && skinStatus[1]) {
        skin=1;
        playerImg=nyanUP[skin];
      } else if (gameState==GAME_START && !skinStatus[1] &&coinCount>=100) {
        coinCount-=100;
        skin=1;
        playerImg=nyanUP[skin];
        skinStatus[1]=!skinStatus[1];
      }
    }
    if (key=='3') {
      if (gameState==GAME_START && skinStatus[2]) {
        skin=2;
        playerImg=nyanUP[skin];
      } else if (gameState==GAME_START && !skinStatus[2] &&coinCount>=100) {
        coinCount-=100;
        skin=2;
        playerImg=nyanUP[skin];
        skinStatus[2]=!skinStatus[2];
      }
    }
  }
}
class Car {
  float x, y;
  float carX, carY;
  float speed;
  PImage carImg;
  boolean isAlive=true;
  float floatTimer;
  Car(int x, int y, float speed) {
    this.x=x;
    this.y=y;
    this.speed=speed;
    carX=(x+6)*80+y*(-30);
    carY=(x+6)*20+y*60;
    if (speed<0) {
      carImg=car[floor(random(4))];
    } else {
      carImg=carR[floor(random(4))];
    }
    floatTimer=0;
  }

   public void display() {
    if (isAlive) {
      if(bombMode){
        drawImage(coinImg, carX, carY+5+sin(floatTimer)*10);
        floatTimer+=TWO_PI/25;
      }else{
        drawImage(carImg, carX, carY);
      }
    }
    if (debugMode) {
      fill(0);
      textSize(30);
      text(x+","+y, carX, carY);
    }
  }

   public void update() {
    if (!bombMode) {
      carX += speed*4;
      carY += speed*1;
      x+=speed/20;
      if (speed>0 && x>14) {
        x=-7;
        carX=(x+6)*80+y*(-30);
        carY=(x+6)*20+y*60;
      } else if (x<-7) {
        x=15;
        carX=(x+6)*80+y*(-30);
        carY=(x+6)*20+y*60;
      }
    }
  }

   public boolean checkCollision(Player player, int playerState) {
    if (playerState==PLAYER_UP||playerState==PLAYER_DOWN||playerState==PLAYER_IDLE) {
      if (isHit(player.offsetX+0.2f, player.offsetY, 0.5f, 1, x, y, 1, 1)) {
        return true;
      }
    }
    return false;
  }
}
class Coin {
  int x, y;
  int itemX, itemY;
  float floatTimer;
  boolean isAlive;

  Coin(int x, int y) {
    this.x=x;
    this.y=y;
    itemX=(x+6)*80+y*(-30);
    itemY=(x+6)*20+y*60;
    isAlive=true;
    floatTimer=0;
  }

   public void display() {
    if (isAlive) {
      drawImage(coinImg, itemX, itemY+5+sin(floatTimer)*10);
      floatTimer+=TWO_PI/25;
    }
  }

   public void checkCollision(Player player) {
    if (isHit(player.offsetX, player.offsetY, 1, 1, x, y, 1, 1)&& isAlive) {
      coinCount++;
      eatMoney.trigger();
      isAlive=false;
    }
  }
}
class Cookie {
  int x, y;
  int itemX, itemY;
  float floatTimer;
  boolean isAlive;

  Cookie(int x, int y) {
    this.x=x;
    this.y=y;
    itemX=(x+6)*80+y*(-30);
    itemY=(x+6)*20+y*60;
    isAlive=true;
    floatTimer=0;
  }

   public void display() {
    if (isAlive) {
      drawImage(cookieImg, itemX, itemY+5+sin(floatTimer)*10);
      floatTimer+=TWO_PI/25;
    }
  }

   public void checkCollision(Player player) {

    if (isHit(player.offsetX, player.offsetY, 1, 1, x, y, 1, 1)&& isAlive) {
      gameState=NYAN_MODE;
      nyan=new NyanCatRun(1200);
      bomb.trigger();
      isAlive=false;
    }
    
  }
}
//code for draw road marking line
 public void roadMarkingLine(int y) {
  if (maps[y].type==ROAD && maps[y-1].type==ROAD) {
    for (int i=0; i<19; i++) {
      landX=i*80+maps[y].y*(-30);
      landY=i*20+maps[y].y*60;

      fill(100);
      //draw line
      if (i%2==0) {
        quad(landX+1, landY-2, landX+81, landY+18, landX+79, landY+22, landX-1, landY+2);
      }
    }
  }
}

//code for draw image form the position point
 public void drawImage(PImage img, float x, float y) {
  if ((img.width-30)%80==0) {
    int n=PApplet.parseInt((img.width-30)/80);
    image(img, x, y-(img.height-20*n));
  }
}


//check collision
 public boolean isHit(float ax, float ay, float aw, float ah, float bx, float by, float bw, float bh) {
  return  ax + aw > bx &&    // a right edge past b left
    ax < bx + bw &&    // a left edge past b right
    ay + ah > by &&    // a top edge past b bottom
    ay < by + bh;
}

 public int score() {
  return 8-player.offsetY;
}

 public void drawScore() {
  if (hiScore<score()) {
    hiScore=score();
  }
  textSize(100);
  fill(255);
  text(score(), 30, 100);
  textSize(30);
  text("HI: "+ hiScore, 30, 150);
  if (debugMode) {
    text(tranY, 30, 230);
    text(player.y+ hiScore, 30, 260);
  }

  textSize(30);
  fill(255, 255, 0);
  text("Coin: "+coinCount, 30, 200);
}


 public void drawSkinBar() {
  textSize(30);
  fill(255);
  text("Avalible Skins", 30, height-120);
  for (int i=0; i<3; i++) {
    if (skinStatus[i]) {
      tint(255);
      image(nyanD[i], 30+120*i, height-100);
    } else {
      tint(128);
      image(nyanD[i], 30+120*i, height-100);
    }
    textSize(20);
    text(i,100+120*i,height-20);
  }
  tint(255);
}
class FlatCoin{
  int x, y;
  int itemX, itemY;
  float floatTimer;
  boolean isAlive;

  FlatCoin(int x, int y) {
    itemX=x;
    itemY=y;
    isAlive=true;
    floatTimer=0;
  }

   public void display() {
    if (isAlive) {
      image(flatCoinImg, itemX, itemY+5+sin(floatTimer)*10);
      floatTimer+=TWO_PI/25;
    }
  }

   public void checkCollision() {
    if (isHit(nyan.nyanX, nyan.nyanY, 100, 100, itemX, itemY, 100, 100)&& isAlive) {
      coinCount++;
      eatMoney.trigger();
      isAlive=false;
    }
  }
}
class Grass extends Map {
  Tree[] trees;
  Coin coin;
  Bomb bomb;
  Cookie cookie;
  Grass(int y) {
    super(y);
    type=GRASS;
    //generate tree
    trees=new Tree[floor(random(5))];
    int newTreeX;
    for (int i=0; i<trees.length; i++) {
      if (floor(random(2))==0) {
        newTreeX=floor(random(3));
        while (checkTreeXreuse(newTreeX, i)) {
          newTreeX=6+floor(random(3));
        }
      } else {
        newTreeX=6+floor(random(3));
        while (checkTreeXreuse(newTreeX, i)) {
          newTreeX=floor(random(3));
        }
      }
      trees[i]=new Tree(newTreeX, y);
    }

    //generate Coin
    if (y%COIN_RATE==0) {
      coin=new Coin(3+floor(random(3)), y);
    }
    
    if(y%BOMB_RATE==0 && y!=0){
      bomb=new Bomb(3+floor(random(3)), y);
    }
    
    if(y%COOKIE_RATE==0 && y!=0){
      cookie=new Cookie(3+floor(random(3)), y);
    }
  }

   public void display() {
    for (int i=0; i<20; i++) {
      if (i<6 || i>14) {
        fill(0xFF0CB43C);
      } else {
        fill(0xFF0ED145);
      }
      landX=i*80+y*(-30);
      landY=i*20+y*60;

      quad(landX, landY-5, landX+80, landY+20-5, landX+110, landY-40-5, landX+30, landY-60-5);
      if (i<6 || i>14) {
        fill(0xFF0A9030);
      } else {
        fill(0xFF0CB43C);
      }
      quad(landX, landY, landX+80, landY+20, landX+80, landY+20-5, landX, landY-5);
      if (debugMode) {
        fill(255);
        textSize(30);
        text(y, landX, landY);
      }
    }
  }

   public void displayObjects() {
    for (int i=0; i<trees.length; i++) {
      trees[i].display();
    }
    if (y%COIN_RATE==0) {
      coin.display();
      coin.checkCollision(player);
        
     
    }
    if (y%BOMB_RATE==0 && y!=0) {
      bomb.display();
      bomb.checkCollision(player);
    }
    
    if (y%COOKIE_RATE==0 && y!=0) {
      cookie.display();
      cookie.checkCollision(player);
    }
  }

   public int checkObjects(int x) {
    //check tree
    for (int i=0; i<trees.length; i++) {
      if (trees[i].x==x) {
        return TREE;
      }
    }
    return -1;
  }

   public boolean checkTreeXreuse(int newTreeX, int n) {
    for (int i=0; i<n; i++) {
      if (trees[i].x==newTreeX) {
        return true;
      }
    }
    return false;
  }
}
class Item {
  int x, y;
  int itemX, itemY;
  float floatTimer;
  boolean isAlive;
  Item(int x, int y) {
    this.x=x;
    this.y=y;
    itemX=(x+6)*80+y*(-30);
    itemY=(x+6)*20+y*60;
    isAlive=true;
    floatTimer=0;
  }

   public void display() {
    if (isAlive) {
      drawImage(coinImg, itemX, itemY+5+sin(floatTimer)*10);
      floatTimer+=TWO_PI/25;
    }
  }

   public boolean checkCollision(Player player) {

    if (isHit(player.offsetX, player.offsetY, 1, 1, x, y, 1, 1)) {
      return true;
    }

    return false;
  }
}
class Map{
  int y;
  int type;
   public void display(){}
   public void displayObjects(){}
  
   public int checkObjects(int x){
    return -1;
  }
  Map(int y){
    this.y=y;
  }
  
}


  
class Player {
  float x, y;
  int offsetX, offsetY;
  int movingTimer;

  Player() {
    x=560;
    y=680;
    offsetX=4;
    offsetY=8;
    movingTimer=0;
  }
  


   public void update() {

    switch(playerState) {
    case PLAYER_IDLE:
      if (maps[12].type==GRASS) {
        drawImage(playerImg, x, y-5);
      } else {
        drawImage(playerImg, x, y);
      }
      break;
    case PLAYER_UP:
      movingTimer+=1;
      x+=3;
      y-=6;
      drawImage(playerImg, x, y-10);
      playerImg=nyanUP[skin];
      break;
    case PLAYER_DOWN:
      movingTimer+=1;
      x-=3;
      y+=6;
      drawImage(playerImg, x, y-10);
      playerImg=nyanD[skin];
      break;
    case PLAYER_LEFT:
      movingTimer+=1;
      x-=8;
      y-=2;
      drawImage(playerImg, x, y-10);
      playerImg=nyanL[skin];
      break;
    case PLAYER_RIGHT:
      movingTimer+=1;
      x+=8;
      y+=2;
      drawImage(playerImg, x, y-10);
      playerImg=nyanR[skin];
      break;
    }

    if (debugMode) {
      fill(0);
      textSize(30);
      text(offsetX+","+offsetY, x+55, y);
    }

    if (movingTimer==10) {
      playerState=PLAYER_IDLE;
      movingTimer=0;
    }
  }
}
class Rainbow{
  int x, y;
  float floatTimer;
  Rainbow(int x, int y) {
    this.x=x;
    this.y=y;
    
    floatTimer=0;
  }

   public void display() {
    
      image(rainbow, x, y+5+sin(floatTimer)*5);
      floatTimer+=TWO_PI/25;
    
  }

  
}
class Road extends Map {
  Car[] cars;
  Road(int y) {
    super(y);
    type=ROAD;

    //generate car
    if (floor(random(3))==0) {
      cars=new Car[2];
      int space=floor(random(4, 16));
      float speed;
      speed=-random(0.4f, 1)*speedRate;

      int newCarX=floor(random(-6, -3));
      cars[0]=new Truck(newCarX, y, speed);
      cars[1]=new Truck(newCarX+space, y, speed);
    } else {
      cars=new Car[3];
      int space=floor(random(4, 12));
      float speed;
      if (floor(random(2))==0) {
        speed=random(0.2f, 1)*speedRate;
      } else {
        speed=-random(0.2f, 1)*speedRate;
      }
      int newCarX=floor(random(-6, -3));
      cars[0]=new Car(newCarX, y, speed);
      cars[1]=new Car(newCarX+space, y, speed);
      cars[2]=new Car(newCarX+15, y, speed);
    }
  }

   public void display() {
    for (int i=0; i<20; i++) {
      if (i<6 || i>14) {
        fill(0xFF303030);
      } else {
        fill(0xFF404040);
      }

      landX=i*80+y*(-30);
      landY=i*20+y*60;
      quad(landX, landY, landX+80, landY+20, landX+110, landY-40, landX+30, landY-60);

      //draw line
      if (i%2==0) {
        quad(landX-14, landY+28, landX+66, landY+48, landX+64, landY+52, landX-14, landY+32);
      }

      if (debugMode) {
        fill(255);
        textSize(30);
        text(y, landX, landY);
      }
    }
  }

   public void displayObjects() {
    for (int i=cars.length-1; i>=0; i--) {
      cars[i].display();
      cars[i].update();
      if (cars[i].checkCollision(player, PLAYER_UP) && gameState==GAME_RUN && cars[i].isAlive) {
        if (bombMode) {
          coinCount++;
          cars[i].isAlive=false;
        } else {
          gameState=GAME_OVER;
          hintTimer=60;
          hintX=-400;
          hintY=150;
        }
      }
    }
  }

   public int checkObjects(int x) {
    //check car
    for (int i=0; i<cars.length; i++) {
      if (cars[i].x==x) {
        return CAR;
      }
    }
    return -1;
  }
}
class Tree {
  int x, y;
  int treeX, treeY;
  PImage treeImg;
  Tree(int x, int y) {
    this.x=x;
    this.y=y;
    treeX=(x+6)*80+y*(-30);
    treeY=(x+6)*20+y*60;
    treeImg=tree[floor(random(4))];
  }



   public void display() {
    drawImage(treeImg, treeX, treeY);
  }
}
/*
//generate coin
coins=new Coin[floor(random(5))];
int newCoinX;
for (int i=0; i<coins.length; i++) {
  if (floor(random(2))==0) {
    newCoinX=floor(random(3));
    while (checkCoinXreuse(newCoinX, i)) {
      newCoinX=6+floor(random(3));
    }
  } else {
    newCoinX=6+floor(random(3));
    while (checkCoinXreuse(newCoinX, i)) {
      newCoinX=floor(random(3));
    }
  }
  coins[i]=new Coin(newCoinX, y);
}
*/
class Truck extends Car{

   Truck(int x, int y, float speed) {
    super(x,y,speed);
    carImg=truck[floor(random(2))];
  }

   public void display() {
    super.display();
  }

   public void update() {
    if (!bombMode) {
      carX += speed*4;
      carY += speed*1;
      x+=speed/20;
      if (speed>0 && x>14) {
        x=-7;
        carX=(x+6)*80+y*(-30);
        carY=(x+6)*20+y*60;
      } else if (x<-7) {
        x=15;
        carX=(x+6)*80+y*(-30);
        carY=(x+6)*20+y*60;
      }
    }
  }

   public boolean checkCollision(Player player, int playerState) {
    if(playerState==PLAYER_UP||playerState==PLAYER_DOWN||playerState==PLAYER_IDLE){
      if(isHit(player.offsetX+0.2f , player.offsetY,0.5f,1,x,y,2,1)){
        return true;
      }
    }
    return false;
  }
}
class Bomb {
  int x, y;
  int itemX, itemY;
  float floatTimer;
  boolean isAlive;

  Bomb(int x, int y) {
    this.x=x;
    this.y=y;
    itemX=(x+6)*80+y*(-30);
    itemY=(x+6)*20+y*60;
    isAlive=true;
    floatTimer=0;
  }

   public void display() {
    if (isAlive) {
      drawImage(bombImg, itemX, itemY+5+sin(floatTimer)*10);
      floatTimer+=TWO_PI/25;
    }
  }

   public void checkCollision(Player player) {

    if (isHit(player.offsetX, player.offsetY, 1, 1, x, y, 1, 1)&& isAlive) {
      bombMode=true;
      bombTimer=300;
      bomb.trigger();
      isAlive=false;
    }
    
  }
}
class NyanCatRun {
  int nyanX, nyanY;
  FlatCoin[] coins=new FlatCoin[11];
  Rainbow[] rainbows=new Rainbow[25];
  int timer;
  int time;
  int nyanIndex;

  NyanCatRun(int time) {
    this.time=time;
    timer=0;
    nyanX=100;
    nyanY=height/2;
    nyanIndex=0;
    for (int i=0; i<11; i++) {
      coins[i]=new FlatCoin(width-120*i,60+120*PApplet.parseInt(random(5)));
    }
    for (int i=0; i<25; i++) {
      rainbows[i]=new Rainbow(nyanX+40-10*i,nyanY-20);
    }
  }

   public void display() {
    background(0xFF0D4278);
    nyanY=mouseY-50;
    if (nyanY<10) {
      nyanY=10;
    } else if (nyanY+110>height) {
      nyanY=height-110;
    }
    //draw coin
    for (int i=0; i<11; i++) {
      coins[i].display();
      coins[i].itemX-=10;
      if(coins[i].itemX+100<0){
        coins[i]=new FlatCoin(width,60+120*PApplet.parseInt(random(5)));
      }
      coins[i].checkCollision();
    }
    
    for (int i=0; i<25; i++) {
      rainbows[i].display();
      rainbows[i].x-=10;
      if(rainbows[i].x+100<=10){
        rainbows[i]=new Rainbow(nyanX+40,nyanY-20);
      }
    }
    
    image(nyanRun[nyanIndex], nyanX, nyanY);
    if (timer%3==0) {
      nyanIndex++;
    }
    if (nyanIndex>4) {
      nyanIndex=0;
    }

    timer++;

    if (timer>time) {
      gameState=GAME_RUN;
    }
  }
}


  public void settings() { size(1280, 720, P2D); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "nyan_cat_adventure" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
